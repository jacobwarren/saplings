"""
Example of using the tool factory capabilities in Saplings.

This example demonstrates how to use the ToolFactory, ToolTemplate, and
ToolSpecification classes to dynamically generate and use tools.
"""

import asyncio
import os
from saplings import (
    ToolFactory,
    ToolFactoryConfig,
    ToolTemplate,
    ToolSpecification,
    SecurityLevel,
)
from saplings.core.model_adapter import LLM, LLMResponse, ModelMetadata, ModelRole

# Mock LLM for demonstration purposes
class MockLLM(LLM):
    """Mock LLM for demonstration purposes."""
    
    async def generate(self, prompt, **kwargs):
        """Generate a response."""
        # In a real application, this would call an actual LLM
        if "add" in prompt.lower():
            return LLMResponse(
                text="return a + b",
                model_uri="mock://model",
                usage={"prompt_tokens": 10, "completion_tokens": 10, "total_tokens": 20},
                metadata={"model": "mock-model"},
            )
        elif "multiply" in prompt.lower():
            return LLMResponse(
                text="return a * b",
                model_uri="mock://model",
                usage={"prompt_tokens": 10, "completion_tokens": 10, "total_tokens": 20},
                metadata={"model": "mock-model"},
            )
        elif "subtract" in prompt.lower():
            return LLMResponse(
                text="return a - b",
                model_uri="mock://model",
                usage={"prompt_tokens": 10, "completion_tokens": 10, "total_tokens": 20},
                metadata={"model": "mock-model"},
            )
        else:
            return LLMResponse(
                text="return a / b if b != 0 else 0",
                model_uri="mock://model",
                usage={"prompt_tokens": 10, "completion_tokens": 10, "total_tokens": 20},
                metadata={"model": "mock-model"},
            )
    
    def get_metadata(self):
        """Get metadata about the model."""
        return ModelMetadata(
            name="mock-model",
            provider="mock-provider",
            version="1.0",
            capabilities=[],
            roles=[ModelRole.GENERAL],
            context_window=4096,
            max_tokens_per_request=1024,
        )


async def run_tool_factory_example():
    """Run an example of the tool factory."""
    print("=== Tool Factory Example ===")
    
    # Create a mock LLM
    model = MockLLM()
    
    # Create a temporary directory for tools
    os.makedirs("temp_tools", exist_ok=True)
    
    # Create a tool factory
    config = ToolFactoryConfig(
        output_dir="temp_tools",
        security_level=SecurityLevel.MEDIUM,
        enable_code_signing=False,
    )
    tool_factory = ToolFactory(model=model, config=config)
    
    # Register a template
    math_template = ToolTemplate(
        id="math_tool",
        name="Math Tool",
        description="A tool for mathematical operations",
        template_code="""
def {{function_name}}({{parameters}}):
    \"\"\"{{description}}\"\"\"
    {{code_body}}
""",
        required_parameters=["function_name", "parameters", "description", "code_body"],
        metadata={"category": "math"},
    )
    tool_factory.register_template(math_template)
    
    print("Registered template: math_tool")
    
    # Create a tool specification with explicit code
    add_spec = ToolSpecification(
        id="add_numbers",
        name="Add Numbers",
        description="A tool to add two numbers",
        template_id="math_tool",
        parameters={
            "function_name": "add_numbers",
            "parameters": "a: int, b: int",
            "description": "Add two numbers together",
            "code_body": "return a + b",
        },
        metadata={"category": "math"},
    )
    
    # Create the tool
    add_tool = await tool_factory.create_tool(add_spec)
    print(f"Created tool: {add_tool.name}")
    
    # Use the tool
    add_instance = add_tool()
    result = add_instance.execute(3, 4)
    print(f"3 + 4 = {result}")
    
    # Create a tool specification with LLM-generated code
    multiply_spec = ToolSpecification(
        id="multiply_numbers",
        name="Multiply Numbers",
        description="A tool to multiply two numbers",
        template_id="math_tool",
        parameters={
            "function_name": "multiply_numbers",
            "parameters": "a: int, b: int",
            "description": "Multiply two numbers together",
            # No code_body - will be generated by LLM
        },
        metadata={"category": "math"},
    )
    
    # Create the tool
    multiply_tool = await tool_factory.create_tool(multiply_spec)
    print(f"Created tool: {multiply_tool.name}")
    
    # Use the tool
    multiply_instance = multiply_tool()
    result = multiply_instance.execute(3, 4)
    print(f"3 * 4 = {result}")
    
    # List all tools
    print("\nRegistered tools:")
    tools = tool_factory.list_tools()
    for tool_id, tool_class in tools.items():
        print(f"- {tool_id}: {tool_class.name}")
    
    # List all templates
    print("\nRegistered templates:")
    templates = tool_factory.list_templates()
    for template_id, template in templates.items():
        print(f"- {template_id}: {template.name}")
    
    # Clean up
    print("\nCleaning up...")
    for filename in os.listdir("temp_tools"):
        os.remove(os.path.join("temp_tools", filename))
    os.rmdir("temp_tools")


async def main():
    """Run the example."""
    await run_tool_factory_example()


if __name__ == "__main__":
    asyncio.run(main())
