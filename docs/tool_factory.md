# Tool Factory

Saplings includes a powerful Tool Factory system that allows you to dynamically generate and use tools at runtime.

## Overview

The Tool Factory system consists of several components:

1. **ToolFactory**: Creates and manages tools
2. **ToolTemplate**: Defines a template for generating tools
3. **ToolSpecification**: Specifies the parameters for a tool
4. **Security Checks**: Validates and secures generated code

## ToolFactory

The `ToolFactory` class is the main entry point for creating and managing tools:

```python
from saplings import ToolFactory, ToolFactoryConfig, SecurityLevel
from saplings.core.model_adapter import LLM

# Create a tool factory
config = ToolFactoryConfig(
    output_dir="tools",
    security_level=SecurityLevel.MEDIUM,
    enable_code_signing=False,
)
tool_factory = ToolFactory(model=model, config=config)
```

## Tool Templates

A `ToolTemplate` defines a template for generating tools:

```python
from saplings import ToolTemplate

# Create a template for mathematical operations
math_template = ToolTemplate(
    id="math_tool",
    name="Math Tool",
    description="A tool for mathematical operations",
    template_code="""
def {{function_name}}({{parameters}}):
    \"\"\"{{description}}\"\"\"
    {{code_body}}
""",
    required_parameters=["function_name", "parameters", "description", "code_body"],
    metadata={"category": "math"},
)

# Register the template
tool_factory.register_template(math_template)
```

## Tool Specifications

A `ToolSpecification` specifies the parameters for a tool:

```python
from saplings import ToolSpecification

# Create a specification for an addition tool
add_spec = ToolSpecification(
    id="add_numbers",
    name="Add Numbers",
    description="A tool to add two numbers",
    template_id="math_tool",
    parameters={
        "function_name": "add_numbers",
        "parameters": "a: int, b: int",
        "description": "Add two numbers together",
        "code_body": "return a + b",
    },
    metadata={"category": "math"},
)
```

## Creating Tools

You can create tools from specifications:

```python
# Create a tool from a specification
add_tool = await tool_factory.create_tool(add_spec)

# Use the tool
result = add_tool().execute(3, 4)
print(result)  # Output: 7
```

## LLM-Generated Tools

You can also let the LLM generate the code body:

```python
# Create a specification with no code body
multiply_spec = ToolSpecification(
    id="multiply_numbers",
    name="Multiply Numbers",
    description="A tool to multiply two numbers",
    template_id="math_tool",
    parameters={
        "function_name": "multiply_numbers",
        "parameters": "a: int, b: int",
        "description": "Multiply two numbers together",
        # No code_body - will be generated by LLM
    },
    metadata={"category": "math"},
)

# Create the tool - the LLM will generate the code body
multiply_tool = await tool_factory.create_tool(multiply_spec)

# Use the tool
result = multiply_tool().execute(3, 4)
print(result)  # Output: 12
```

## Security Levels

The Tool Factory supports different security levels:

```python
from saplings import SecurityLevel

# Low security - basic checks
config = ToolFactoryConfig(security_level=SecurityLevel.LOW)

# Medium security - standard checks (default)
config = ToolFactoryConfig(security_level=SecurityLevel.MEDIUM)

# High security - strict checks
config = ToolFactoryConfig(security_level=SecurityLevel.HIGH)
```

The security checks include:

- **LOW**: Basic syntax validation
- **MEDIUM**: Checks for dangerous function calls
- **HIGH**: Checks for dangerous imports, network access, etc.

## Managing Tools

The Tool Factory provides methods for managing tools:

```python
# Get a tool by ID
add_tool = tool_factory.get_tool("add_numbers")

# List all tools
tools = tool_factory.list_tools()
for tool_id, tool_class in tools.items():
    print(f"Tool: {tool_id}, Name: {tool_class.name}")

# List all templates
templates = tool_factory.list_templates()
for template_id, template in templates.items():
    print(f"Template: {template_id}, Name: {template.name}")
```

## Integration with Other Components

The Tool Factory integrates with other Saplings components:

### Integration with Executor

```python
from saplings import Executor, ExecutorConfig

# Create an executor
executor = Executor(model=model, config=ExecutorConfig())

# Create a tool
add_tool = await tool_factory.create_tool(add_spec)

# Use the tool in the executor
result = await executor.execute("Add 3 and 4", tools=[add_tool])
```

### Integration with GraphRunner

```python
from saplings import GraphRunner, GraphRunnerConfig, AgentNode

# Create a graph runner
graph_runner = GraphRunner(model=model, config=GraphRunnerConfig())

# Register an agent that uses tools
agent = AgentNode(
    id="math_agent",
    name="Math Agent",
    role="calculator",
    description="An agent that performs mathematical operations",
    capabilities=["math"],
)
graph_runner.register_agent(agent)

# Create a tool
add_tool = await tool_factory.create_tool(add_spec)

# Use the tool in the agent
# The agent can now use the add_tool during negotiations
```

### Cleaning Up Resources

When you're done with the tool factory, you should clean up any resources it's using:

```python
# Clean up resources
tool_factory.cleanup()
```

This is especially important when using sandbox execution, as it ensures that any running containers or processes are properly terminated.

## Advanced Usage

### Custom Validation

You can implement custom validation for generated code:

```python
def custom_validator(code):
    # Custom validation logic
    if "import os" in code:
        return False, "OS module import not allowed"
    return True, ""

# Use the custom validator
with patch.object(tool_factory, "_validate_tool_code", side_effect=custom_validator):
    tool = await tool_factory.create_tool(spec)
```

### Code Signing

You can enable code signing for generated tools to ensure their integrity and authenticity:

```python
from saplings import SigningLevel

# Basic signing (hash verification)
config = ToolFactoryConfig(
    signing_level=SigningLevel.BASIC,
)

# Advanced signing (cryptographic signatures)
config = ToolFactoryConfig(
    signing_level=SigningLevel.ADVANCED,
    signing_key_path="keys/signing_key.pem",
)

tool_factory = ToolFactory(model=model, config=config)
```

You can generate key pairs for advanced signing:

```python
from saplings.tool_factory.code_signing import generate_key_pair

# Generate a key pair
private_key_path, public_key_path = generate_key_pair("keys", "signing_key")
```

### Sandbox Execution

You can specify a sandbox type for secure tool execution:

```python
from saplings import SandboxType

# No sandbox (default)
config = ToolFactoryConfig(
    sandbox_type=SandboxType.NONE,
)

# Docker sandbox
config = ToolFactoryConfig(
    sandbox_type=SandboxType.DOCKER,
    docker_image="python:3.9-slim",
    sandbox_timeout=30,
)

# E2B cloud sandbox
config = ToolFactoryConfig(
    sandbox_type=SandboxType.E2B,
    e2b_api_key="your-e2b-api-key",
    sandbox_timeout=30,
)

tool_factory = ToolFactory(model=model, config=config)
```

When a tool is executed in a sandbox:

1. The code is verified using the signature (if signing is enabled)
2. The code is executed in the specified sandbox environment
3. The result is returned to the caller

This provides an additional layer of security for dynamically generated tools.

## Conclusion

The Tool Factory system in Saplings provides a powerful way to dynamically generate and use tools at runtime. By defining templates and specifications, you can create a wide variety of tools that can be used by agents to solve complex tasks.
