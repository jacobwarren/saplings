"""
ToolFactory module for Saplings.

This module provides the ToolFactory class for dynamic tool synthesis.
"""

import importlib
import inspect
import json
import logging
import os
import re
import sys
import tempfile
from typing import Any, Dict, List, Optional, Set, Tuple, Type, Union

from saplings.core.model_adapter import LLM
from saplings.core.plugin import PluginType, ToolPlugin, register_plugin
from saplings.tool_factory.config import (
    ToolSpecification,
    ToolFactoryConfig,
    ToolTemplate,
    SecurityLevel,
    SandboxType,
    SigningLevel,
)
from saplings.tool_factory.sandbox import get_sandbox
from saplings.tool_factory.code_signing import CodeSigner, SignatureVerifier
from saplings.tool_factory.tool_validator import ToolValidator, ValidationResult

logger = logging.getLogger(__name__)


class ToolFactory:
    """
    Factory for dynamic tool synthesis.

    This class provides functionality for:
    - Registering tool templates
    - Generating tool code from specifications
    - Validating and securing generated code
    - Creating and registering tool plugins
    """

    def __init__(
        self,
        model: LLM,
        config: Optional[ToolFactoryConfig] = None,
    ):
        """
        Initialize the tool factory.

        Args:
            model: LLM model to use for code generation
            config: Configuration for the tool factory
        """
        self.model = model
        self.config = config or ToolFactoryConfig()

        # Initialize template and tool registries
        self.templates: Dict[str, ToolTemplate] = {}
        self.tools: Dict[str, Type[ToolPlugin]] = {}

        # Create the output directory if it doesn't exist
        os.makedirs(self.config.output_dir, exist_ok=True)

        # Initialize components
        self.validator = ToolValidator(self.config)
        self.code_signer = CodeSigner(self.config)
        self.signature_verifier = SignatureVerifier(self.config)

        # Initialize sandbox
        self.sandbox = None  # Lazy initialization

    def register_template(self, template: ToolTemplate) -> None:
        """
        Register a tool template.

        Args:
            template: Template to register

        Raises:
            ValueError: If a template with the same ID already exists
        """
        if template.id in self.templates:
            raise ValueError(f"Template with ID '{template.id}' already exists")

        self.templates[template.id] = template
        logger.info(f"Registered template: {template.name} (ID: {template.id})")

    async def generate_tool_code(self, spec: ToolSpecification) -> str:
        """
        Generate code for a tool based on a specification.

        Args:
            spec: Tool specification

        Returns:
            str: Generated code

        Raises:
            ValueError: If the template doesn't exist or parameters are missing
        """
        # Verify that the template exists
        if spec.template_id not in self.templates:
            raise ValueError(f"Template with ID '{spec.template_id}' does not exist")

        template = self.templates[spec.template_id]

        # Verify that all required parameters are provided
        for param in template.required_parameters:
            if param not in spec.parameters:
                # Check if this parameter can be generated by the LLM
                if param == "code_body":
                    # Generate the code body using the LLM
                    spec.parameters["code_body"] = await self._generate_code_with_llm(spec)
                else:
                    raise ValueError(f"Required parameter '{param}' is missing")

        # Generate the code by replacing placeholders in the template
        code = template.template_code
        for param, value in spec.parameters.items():
            placeholder = f"{{{{{param}}}}}"
            code = code.replace(placeholder, str(value))

        return code

    async def _generate_code_with_llm(self, spec: ToolSpecification) -> str:
        """
        Generate code body using the LLM.

        Args:
            spec: Tool specification

        Returns:
            str: Generated code body
        """
        # Create the prompt
        prompt = f"""
        You are a code generator for a tool called "{spec.name}".

        Description: {spec.description}

        Generate the code body (implementation) for this tool. Do not include the function signature or docstring.
        Only provide the actual implementation code that would go inside the function body.

        For example, if the tool adds two numbers, you would generate:
        return a + b

        Generate the code body now:
        """

        # Generate the code body
        response = await self.model.generate(prompt=prompt.strip())

        return response.text.strip()

    async def create_tool(self, spec: ToolSpecification) -> Type[ToolPlugin]:
        """
        Create a tool from a specification.

        Args:
            spec: Tool specification

        Returns:
            Type[ToolPlugin]: Tool class

        Raises:
            ValueError: If the tool code is invalid or fails security checks
        """
        # Generate the tool code
        code = await self.generate_tool_code(spec)

        # Validate the code
        is_valid, validation_error = self._validate_tool_code(code)
        if not is_valid:
            raise ValueError(f"Invalid tool code: {validation_error}")

        # Perform security checks
        is_secure, security_error = self._perform_security_checks(code)
        if not is_secure:
            raise ValueError(f"Security check failed: {security_error}")

        # Create the tool class
        tool_class = self._create_tool_class(spec, code)

        # Register the tool
        self.tools[spec.id] = tool_class

        # Save the tool to disk
        self._save_tool(spec, code)

        logger.info(f"Created tool: {spec.name} (ID: {spec.id})")

        return tool_class

    def _validate_tool_code(self, code: str) -> Tuple[bool, str]:
        """
        Validate the generated code.

        Args:
            code: Generated code

        Returns:
            Tuple[bool, str]: (is_valid, error_message)
        """
        # Use the validator to check the code
        validation_result = self.validator.validate(code)

        # Log warnings
        for warning in validation_result.warnings:
            logger.warning(f"Tool code warning: {warning}")

        return validation_result.is_valid, validation_result.error_message or ""

    def _perform_security_checks(self, code: str) -> Tuple[bool, str]:
        """
        Perform security checks on the generated code.

        Args:
            code: Generated code

        Returns:
            Tuple[bool, str]: (is_secure, error_message)
        """
        # The validator already performs security checks, but we'll add additional
        # checks specific to the tool factory here if needed

        # For now, we'll just use the validator's security checks
        validation_result = self.validator._check_security(code)

        return validation_result.is_valid, validation_result.error_message or ""

    def _create_tool_class(self, spec: ToolSpecification, code: str) -> Type[ToolPlugin]:
        """
        Create a tool class from the specification and code.

        Args:
            spec: Tool specification
            code: Generated code

        Returns:
            Type[ToolPlugin]: Tool class
        """
        # Create a namespace for the tool
        namespace = {}

        # Execute the code in the namespace
        exec(code, namespace)

        # Find the function in the namespace
        function_name = None
        for name, obj in namespace.items():
            if callable(obj) and not name.startswith("_"):
                function_name = name
                break

        if not function_name:
            raise ValueError("No function found in the generated code")

        # Get the function
        function = namespace[function_name]

        # Sign the code if enabled
        signature_info = self.code_signer.sign(code)

        # Create the tool class
        class DynamicTool(ToolPlugin):
            """Dynamically generated tool."""

            id = spec.id
            name = spec.name
            description = spec.description
            version = "1.0.0"
            plugin_type = PluginType.TOOL
            _code = code
            _signature_info = signature_info
            _sandbox_type = self.config.sandbox_type

            def execute(self, *args, **kwargs):
                """Execute the tool."""
                # Verify the signature if enabled
                if not self.signature_verifier.verify(self._code, self._signature_info):
                    raise ValueError("Code signature verification failed")

                # If sandboxing is enabled, execute in sandbox
                if self._sandbox_type != SandboxType.NONE:
                    # Lazy initialize the sandbox
                    if self.tool_factory.sandbox is None:
                        self.tool_factory.sandbox = get_sandbox(self.tool_factory.config)

                    # Execute in sandbox
                    return self.tool_factory.sandbox.execute(
                        code=self._code,
                        function_name=function_name,
                        args=args,
                        kwargs=kwargs,
                    )

                # Otherwise, execute directly
                return function(*args, **kwargs)

        # Set the class name
        DynamicTool.__name__ = f"{spec.id.capitalize()}Tool"

        # Set a reference to the tool factory
        DynamicTool.tool_factory = self
        DynamicTool.signature_verifier = self.signature_verifier

        # Register the tool as a plugin
        register_plugin(DynamicTool)

        return DynamicTool

    def _save_tool(self, spec: ToolSpecification, code: str) -> None:
        """
        Save the tool to disk.

        Args:
            spec: Tool specification
            code: Generated code
        """
        # Create the file path
        file_path = os.path.join(self.config.output_dir, f"{spec.id}.py")

        # Sign the code if enabled
        signature_info = self.code_signer.sign(code)

        # Convert signature info to JSON
        signature_json = json.dumps(signature_info, indent=2)

        # Add a header to the code
        header = f"""
# Generated tool: {spec.name}
# Description: {spec.description}
# Generated by: ToolFactory
# Signature: {signature_json}
"""

        # Save the code to disk
        with open(file_path, "w") as f:
            f.write(header + code)

        logger.info(f"Saved tool to: {file_path}")

        # Save signature info separately if advanced signing is enabled
        if signature_info.get("signature_type") == "advanced":
            sig_path = os.path.join(self.config.output_dir, f"{spec.id}.sig")
            with open(sig_path, "w") as f:
                f.write(signature_json)
            logger.info(f"Saved signature to: {sig_path}")

    def get_tool(self, tool_id: str) -> Type[ToolPlugin]:
        """
        Get a tool by ID.

        Args:
            tool_id: ID of the tool

        Returns:
            Type[ToolPlugin]: Tool class

        Raises:
            ValueError: If the tool doesn't exist
        """
        if tool_id not in self.tools:
            raise ValueError(f"Tool with ID '{tool_id}' does not exist")

        return self.tools[tool_id]

    def list_tools(self) -> Dict[str, Type[ToolPlugin]]:
        """
        List all registered tools.

        Returns:
            Dict[str, Type[ToolPlugin]]: Dictionary of tool ID to tool class
        """
        return self.tools.copy()

    def list_templates(self) -> Dict[str, ToolTemplate]:
        """
        List all registered templates.

        Returns:
            Dict[str, ToolTemplate]: Dictionary of template ID to template
        """
        return self.templates.copy()

    def cleanup(self) -> None:
        """
        Clean up resources used by the tool factory.

        This method should be called when the tool factory is no longer needed
        to release any resources it's using.
        """
        # Clean up the sandbox if it exists
        if self.sandbox is not None:
            self.sandbox.cleanup()
            self.sandbox = None

        logger.info("Cleaned up tool factory resources")
